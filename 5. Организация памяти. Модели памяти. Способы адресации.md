# **Организация памяти**
- Память состоит из ячеек, обычно размером в **1 байт** (8 бит).
- Каждая ячейка имеет уникальный номер — **адрес**.
- Для данных большего размера ([[5.1. Представление данных#**Основные типы данных**|слово]], двойное слово) адресом считается адрес их **младшего байта** (в архитектуре Intel). 

### **Физический адрес** 
— номер конкретной ячейки в микросхеме [[2. Структура ЭВМ#^13b9a1|оперативной памяти (RAM)]].
### **Виртуальный адрес** 
— адрес, который видит и использует программа.

#### **Порядок байт многобайтового числа**
##### *1. Little-endian (Порядок «младшим концом»)*
При таком подходе ***младший байт числа записывается по меньшему адресу памяти***. Характерна для всех микропроцессоров фирмы Intel.
- Пример: Если мы сохраняем 32-разрядное (4 байта) число в ячейки с адресами 200, 201, 202 и 203, то адрес самого числа будет 200. В ячейке 200 будет лежать самый младший байт числа.
##### *2. Big-endian (Порядок «старшим концом»)*
При этом подходе ***по меньшему адресу располагается старший байт числа.*** Характерна для микропроцессоров фирмы Motorola и больших ЭВМ фирмы IBM.
- Число записывается в памяти так, как мы привыкли читать его слева направо.

***Механизм управления [[2. Структура ЭВМ#^13b9a1|памятью]] полностью аппаратный***, т.е. программа сама не может сформировать физический адрес памяти на адресной шине.  

# **Модель памяти**
— ***логическая схема организации [[3. Функциональная и структурная организация процессора#Адресное пространство*|адресного пространства]], которая определяет, как оперативная память представляется программе и каким образом процессор обращается к данным и командам***.

Микропроцессор ***аппаратно поддерживает*** несколько моделей использования оперативной памяти:
- ***сегментированную модель***
-  ***страничную модель***
-  ***плоскую модель***
## **Сегментированная модель памяти**

### **Сегмент памяти** 
— ***логически выделенная непрерывная область в оперативной памяти, которая используется программой для хранения определенного типа информации*** (кода, данных или стека). ***Поддерживается на аппаратном уровне***
  
### **Сегментация** 
— ***механизм [[5. Организация памяти. Модели памяти. Способы адресации#**Адресация**|адресации]], обеспечивающий существование нескольких независимых адресных пространств*** как в пределах одной задачи, так и в системе в целом для защиты задач от взаимного влияния.

Каждая ***программа*** в общем случае ***может состоять из любого количества сегментов, но непосредственный доступ она имеет только к 3 основным сегментам и к 3 дополнительным сегментам, обслуживаемых 6 [[3. Функциональная и структурная организация процессора#**Сегментные регистры**|сегментными регистрами]].*** 

#### **Основные сегменты**
- *Сегмент  кодов ([[6.1. Директивы ассемблера. Операторы ассемблера.#**1. Группа управления структурой и сегментацией**|.CODE]])* – ***содержит машинные команды*** для выполнения. Обычно первая выполняемая команда находится в начале этого сегмента, и операционная система передает управление по адресу данного сегмента  для выполнения программы. ***Регистр сегмента кодов (CS) адресует данный сегмент***.
- *Сегмент данных (.DATA)* – ***содержит определенные данные, константы и рабочие области***, необходимые программе. Регистр сегмента данных ***(DS)*** адресует данный сегмент.
- *Сегмент стека (.STACK)*. ***Стек содержит адреса возврата как для программы*** (для возврата в операционную систему), ***так и для  вызовов подпрограмм*** (для возврата в главную программу). Регистр сегмента стека (***SS)*** адресует данный сегмент. ***Адрес текущей вершины стека задается регистрами SS:[[3. Функциональная и структурная организация процессора#**Регистры общего назначения**|ESP]]***.

Регистры дополнительных сегментов (ES, FS, GS), предназначены для специального использования.  

### **Доступ к данным внутри сегмента**

К данным внутри сегмента ***обращение производится относительно начала сегмента линейно***, т.е. начиная с 0 и заканчивая адресом, равным размеру сегмента. ***Для обращения к любому адресу в программе, компьютер складывает адрес в регистре сегмента и*** *смещение* - ***расположение требуемого адреса относительно начала сегмента***. Например, первый байт в сегменте кодов имеет смещение 0, второй байт – 1 и так далее.  
  
Таким образом, ***для обращения к физическому адресу ОЗУ необходимо определить адрес начала сегмента и смещение внутри сегмента.***  
***Физический адрес принято записывать***:
`сегмент : смещение`

### **Таблица дескрипторов**

***ОС строит для каждого исполняемого процесса соответствующую таблицу дескрипторов сегментов*** и ***при размещении*** каждого из ***сегментов в*** ОП или внешней ***памяти в дескрипторе отмечает его текущее местоположение*** (бит присутствия). 

***Дескриптор содержит поле адреса, с которого сегмент начинается и поле длины сегмента***. Благодаря этому можно 
1) ***осуществлять контроль размещения сегментов без наложения друг на друга***
2) ***следить за тем, обращается ли код исполняющейся задачи за пределы текущего сегмента.***

***В дескрипторе содержатся также данные о правах доступа к сегменту*** (запрет на модификацию, можно ли его предоставлять другой задаче) и защита.

*Достоинства:*
1. общий ***объем виртуальной памяти превосходит объем физической памяти***
2. ***возможность размещать в памяти больше задач*** (до определенного предела) увеличивает загрузку системы и более эффективно используются ресурсы системы

*Недостатки:*
1. ***увеличивается время на доступ к искомой ячейке памяти***, т.к. должны вначале прочитать дескриптор сегмента, а потом уже, используя его данные, можно вычислить физический адрес;
2. ***фрагментация — явление, при котором оперативная память (или диск) используется неэффективно из-за того, что свободное пространство разбито на мелкие изолированные части.***;
3. ***потери памяти на размещение дескрипторных таблиц***;
4. ***потери процессорного времени на обработку дескрипторных таблиц***.

## **Страничная модель памяти**

Страничная модель памяти — это надстройка над сегментной моделью.
### **Страница**  
— ***непрерывный блок виртуальной памяти фиксированной длины, кратный степени 2*** (обычно 4 Кб). Описывается 1 записью в таблице страниц.

***Программа также разбивается на фрагменты - страницы. Все фрагменты программы одинаковой длины, кроме последней страницы. Память разбивается на физические страницы, а программа - на виртуальные страницы.***

***Адресация между страницами является сквозной и непрерывной в виртуальном пространстве***

Страничная модель памяти ***поддерживается только в [[защищенном режиме работы микропроцессора]]***.

*Основное достоинство* страничного способа распределения памяти - ***минимально возможная фрагментация***. *Недостаток*: такая организация памяти ***не использует память достаточно эффективно за счет фиксированного размера страниц.***  

|**Характеристика**|**Сегменты**|**Страницы**|
|---|---|---|
|**Длина**|Переменная (зависит от данных/кода)|Фиксированная (обычно 4 КБ)|
|**Кто видит?**|Программист и компилятор|Операционная система (ядро)|
|**Зачем нужно?**|Логическое разделение кода и данных|Эффективное использование физ. памяти|
|**Фрагментация**|Внешняя (дырки между блоками)|Внутренняя (пустота в конце страницы)|
|**Отображение**|Базовый адрес + Смещение|Таблицы страниц (виртуальный -> физ)|

## **Плоская модель памяти**
  
***Плоская модель памяти предполагает, что задача состоит из одного сегмента, который, в свою очередь, разбит на страницы.*** В этой модели вся память представляется как один гигантский непрерывный массив байтов с адресами от $0$ до $2^{N}-1$.

*Достоинства*:
- при использовании плоской модели памяти ***упрощается создание и операционной системы, и систем программирования;***
- ***уменьшаются расходы памяти на поддержку системных информационных структур***.

В абсолютном большинстве современных 32(64)-разрядных операционных систем (для микропроцессоров Intel) используется плоская модель памяти.

### **Задание модели памяти**
В программе можно задать модель памяти при помощи [[6.1. Директивы ассемблера. Операторы ассемблера.#**1. Группа управления структурой и сегментацией**|директивы .MODEL]]

| Модель памяти | Адресация кода | Адресация данных | Операционная система | Чередование кода и данных |
| ------------- | ------------------ | -------------------- | ------------------------ | ----------------------------- |
| TINY          | NEAR               | NEAR                 | MS-DOS                   | Допустимо                     |
| SMALL         | NEAR               | NEAR                 | MS-DOS, Windows          | Нет                           |
| MEDIUM        | FAR                | NEAR                 | MS-DOS, Windows          | Нет                           |
| COMPACT       | NEAR               | FAR                  | MS-DOS, Windows          | Нет                           |
| LARGE         | FAR                | FAR                  | MS-DOS, Windows          | Нет                           |
| HUGE          | FAR                | FAR                  | MS-DOS, Windows          | Нет                           |
| FLAT          | NEAR               | NEAR                 | Windows NT               | Допустимо                     |

> [!note] Модель flat
> Модель flat предполагает несегментированную конфигурацию программы и используется только в 32-разрядных операционных системах.

# **Адресация** 
— ***механизм определения местонахождения данных (операндов) или следующей команды в памяти компьютера.*** В архитектуре процессора это механизм, с помощью которого ***[[3. Функциональная и структурная организация процессора#Устройство управления (УУ)|УУ]] вычисляет реальный (исполнительный) адрес в адресном пространстве***

### **Ближняя и дальняя адресация (Near vs Far)**

Эти понятия ***напрямую связаны с сегментной моделью памяти***, где адрес состоит из двух частей: сегмента и смещения

| Характеристика         | Ближняя адресация (Near)                            | Дальняя адресация (Far)                            |
| ---------------------- | --------------------------------------------------- | -------------------------------------------------- |
| Суть                   | Обращение внутри того же самого сегмента.           | Обращение к объекту в другом сегменте.             |
| Компоненты адреса      | Только смещение (Offset).                           | Селектор сегмента + смещение (Segment:Offset).     |
| Размер адреса          | Короче (обычно 16 или 32 бита).                     | Полный (длинный) адрес.                            |
| Скорость и объем       | Быстрее и компактнее.                               | Медленнее (требует загрузки сегментного регистра). |
| Типичные модели памяти | `TINY`, `SMALL`.                                    | `MEDIUM`, `LARGE`, `HUGE`.                         |
| Случаи использования   | Локальные переменные, функции внутри одного модуля. | Вызов внешних библиотек, доступ к видеопамяти.     |
| Инструментарий         | Стандартные указатели.                              | Специальные указатели (например, `far ptr`).       |
### **Режимы адресации операндов**

Режим адресации определяет, как именно процессор находит данные для выполнения команды. 

| Метод адресации     | Формула / Суть             | Пример MASM                 | Применение                    |
| ------------------- | -------------------------- | --------------------------- | ----------------------------- |
| 1. Непосредственная | Операнд в коде             | `mov eax, 5`                | Константы, флаги              |
| 2. Регистровая      | Операнд в регистре         | `mov eax, ebx`              | Пересылка между регистрами    |
| 3. Прямая           | Фиксированный адрес        | `mov eax, [1234h]`          | Глобальные переменные         |
|                     |                            |                             |                               |
| 4. Косвенная        | Адрес вычисляется          | [Base + Index*Scale + Disp] | Динамические структуры        |
| ∟ Регистровая косв. | `[Регистр]` содержит адрес | `mov eax, [ebx]`            | Разыменование указателя       |
| ∟ Базовая           | `[База + Смещение]`        | `mov eax, [ebp + 8]`        | Параметры функции в стеке     |
| ∟ Индексная         | `[Индекс * Масштаб]`       | `mov eax, [esi * 4]`        | Элементы массива (int, float) |
| ∟ Базово-индексная  | `[База + Индекс * М]`      | `mov eax, [ebx + esi*8]`    | Массивы структур или double   |
| ∟ Относительная     | `[RIP + Смещение]`         | `mov eax, [rel my_var]`     | Позиционно-независимый код    |
    
