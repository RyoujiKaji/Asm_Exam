# **Организация памяти**
- Память состоит из ячеек, обычно размером в **1 байт** (8 бит).
- Каждая ячейка имеет уникальный номер — **адрес**.
- Для данных большего размера ([[слово]], двойное слово) адресом считается адрес их **младшего байта** (в архитектуре Intel). 

#### **Порядок байт многобайтового числа**
##### *1. Little-endian (Порядок «младшим концом»)*
При таком подходе младший байт числа записывается по меньшему адресу памяти. Характерна для всех микропроцессоров фирмы Intel.
- Пример: Если мы сохраняем 32-разрядное (4 байта) число в ячейки с адресами 200, 201, 202 и 203, то адрес самого числа будет 200. В ячейке 200 будет лежать самый младший байт числа.
##### *2. Big-endian (Порядок «старшим концом»)*
При этом подходе по меньшему адресу располагается старший байт числа. Характерна для микропроцессоров фирмы Motorola и больших ЭВМ фирмы IBM.
- Число записывается в памяти так, как мы привыкли читать его слева направо.

Механизм управления [[2. Структура ЭВМ#^13b9a1|памятью]] полностью аппаратный, т.е. программа сама не может сформировать физический адрес памяти на адресной шине.  

# **Модель памяти**
— логическая схема организации [[3. Функциональная и структурная организация процессора#**Адресное пространство**|адресного пространства]], которая определяет, как оперативная память представляется программе и каким образом процессор обращается к данным и командам.

Микропроцессор аппаратно поддерживает несколько моделей использования оперативной памяти:
- сегментированную модель
-  страничную модель
-  плоскую модель
## **Сегментированная модель памяти**

В сегментированной модели память для программы делится на непрерывные области памяти, называемые  сегментами. Программа может обращаться только к данным, которые находятся в этих сегментах.  
Сегмент представляет собой независимый, поддерживаемый на аппаратном уровне блок памяти.  
  
Сегментация - механизм адресации, обеспечивающий существование нескольких независимых адресных пространств как в пределах одной задачи, так и в системе в целом для защиты задач от взаимного влияния.

Каждая программа в общем случае может состоять из любого количества сегментов, но непосредственный доступ она имеет только к 3 основным сегментам и к 3 дополнительным сегментам, обслуживаемых 6 сегментными регистрами. К основным сегментам относятся:

- Сегмент  кодов (.CODE) – содержит машинные команды для выполнения. Обычно первая выполняемая команда находится в начале этого сегмента, и операционная система передает управление по адресу данного сегмента  для выполнения программы. Регистр сегмента кодов (CS) адресует данный сегмент.
- Сегмент данных (.DATA) – содержит определенные данные, константы и рабочие  области, необходимые программе. Регистр сегмента данных (DS) адресует данный сегмент.
- Сегмент стека (.STACK). Стек содержит адреса возврата как для программы (для возврата в операционную систему), так и для  вызовов подпрограмм (для возврата в главную программу). Регистр сегмента стека (SS) адресует данный сегмент. Адрес текущей вершины стека задается регистрами SS:ESP.

Регистры дополнительных сегментов (ES, FS, GS), предназначены для специального использования.  
  
Для доступа к данным внутри сегмента обращение производится относительно начала сегмента линейно, т.е. начиная с 0 и заканчивая адресом, равным размеру сегмента. Для обращения к любому адресу в программе, компьютер складывает адрес в регистре сегмента и смещение - расположение требуемого адреса относительно начала сегмента. Например, первый байт в сегменте кодов имеет смещение 0, второй байт – 1 и так далее.  
  
Таким образом, для обращения к конкретному физическому адресу ОЗУ необходимо определить адрес начала сегмента и смещение внутри сегмента.  
Физический адрес принято записывать парой этих значений, разделенных двоеточием

**сегмент : смещение**

## **Страничная модель памяти**

Страничная модель памяти – это надстройка над сегментной моделью. ОЗУ делится на блоки фиксированного размера, кратные степени 2, например 4 Кб. Каждый такой блок называется страницей. Основное достоинство страничного способа распределения памяти - минимально возможная фрагментация. Однако такая организация памяти не использует память достаточно эффективно за счет фиксированного размера страниц.  

## **Плоская модель памяти**
  
Плоская модель памяти предполагает, что задача состоит из одного сегмента, который, в свою очередь, разбит на страницы.  
Достоинства:

- при использовании плоской модели памяти упрощается создание и операционной системы, и систем программирования;
- уменьшаются расходы памяти на поддержку системных информационных структур.

В абсолютном большинстве современных 32(64)-разрядных операционных систем (для микропроцессоров Intel) используется плоская модель памяти.

В программе можно задать модель памяти при помощи [[директивы .MODEL]]

| Модель памяти | Адресация кода | Адресация данных | Операционная система | Чередование кода и данных |
| ------------- | ------------------ | -------------------- | ------------------------ | ----------------------------- |
| TINY          | NEAR               | NEAR                 | MS-DOS                   | Допустимо                     |
| SMALL         | NEAR               | NEAR                 | MS-DOS, Windows          | Нет                           |
| MEDIUM        | FAR                | NEAR                 | MS-DOS, Windows          | Нет                           |
| COMPACT       | NEAR               | FAR                  | MS-DOS, Windows          | Нет                           |
| LARGE         | FAR                | FAR                  | MS-DOS, Windows          | Нет                           |
| HUGE          | FAR                | FAR                  | MS-DOS, Windows          | Нет                           |
| FLAT          | NEAR               | NEAR                 | Windows NT               | Допустимо                     |

> [!note] Модель flat
> Модель flat предполагает несегментированную конфигурацию программы и используется только в 32-разрядных операционных системах.

# **Адресация** 
— способ определения местонахождения данных (операндов) или следующей команды в памяти компьютера. В архитектуре процессора это механизм, с помощью которого устройство управления вычисляет реальный (исполнительный) адрес в адресном пространстве

### Ближняя и дальняя адресация (Near vs Far)

Эти понятия напрямую связаны с **сегментной моделью памяти**, где адрес состоит из двух частей: сегмента и смещения1.

#### 1. Ближняя адресация (Near)

- **Что это:** Обращение к объекту (данным или коду), который находится внутри **того же самого сегмента**, что и текущая команда2.
    
- **Как работает:** Процессор использует только **смещение (offset)**3. Значение сегментного регистра (CS для кода или DS для данных) остается неизменным4.
    
- **Когда используется:** В моделях памяти `SMALL` или `TINY`, а также внутри функций и при обращении к локальным переменным5.
    
- **Плюсы:** Код выполняется быстрее и занимает меньше места, так как адрес короче (обычно 16 или 32 бита)6.
    

#### 2. Дальняя адресация (Far)

- **Что это:** Обращение к объекту, который находится в **другом сегменте** памяти7.
    
- **Как работает:** Процессор должен загрузить **полный адрес**, состоящий из селектора сегмента и смещения (пара `segment:offset`)8.
    
- **Когда используется:** * В моделях памяти `MEDIUM`, `LARGE` или `HUGE`9.
    
    - При вызове функций из других модулей или библиотек.
        
    - При обращении к видеопамяти или специфическим системным данным в реальном режиме.
        
- **Особенности:** Требует использования специальных указателей, таких как `far ptr` (в коде)10.
    

---

### Режимы адресации операндов

Режим адресации определяет, как именно процессор находит данные для выполнения команды. Согласно документации, выделяют следующие основные виды11:

#### 1. Непосредственная адресация (Immediate)

- **Суть:** Операнд (число) находится прямо в коде команды12.
    
- **Пример:** `MOV EAX, 5` — число 5 вшито в команду13.
    

#### 2. Регистровая адресация (Register)

- **Суть:** Операнд находится в одном из внутренних регистров процессора14.
    
- **Пример:** `MOV EAX, EBX` — данные копируются из одного регистра в другой15.
    

#### 3. Прямая адресация (Direct)

- **Суть:** В команде указан конкретный числовой адрес ячейки памяти16.
    
- **Пример:** `MOV EAX, [1234h]` — взять данные из ячейки с адресом 1234h17.
    

#### 4. Косвенная адресация (Indirect)

Исполнительный адрес операнда вычисляется динамически. В архитектуре Intel для этого используется общая формула вычисления эффективного адреса (EA)18:

$$EA = (База) + (Индекс) \times Масштаб + Смещение$$

- **Регистровая косвенная:** Адрес хранится в регистре, который указывается в квадратных скобках19. Пример: `MOV EAX, [EBX]`20.
    
- **Относительная:** Адрес вычисляется как сумма значения в поле команды и текущего счетчика команд21. Это делает программу **перемещаемой** (ее можно загрузить в любой участок памяти без правки адресов)22.
    
- **Базовая:** Используется регистр (база) и фиксированное смещение23. Пример: `[EBP + 8]` часто используется для доступа к параметрам в стеке24.
    
- **Индексная:** Используется адрес начала массива и регистр-индекс для доступа к элементам25. При этом может применяться **масштабирование** (умножение индекса на 2, 4 или 8), что удобно для массивов с элементами разного размера26.
    
