# **Логика формирования переходов**
1. В коде различные блоки помечаются метками
2. Арифметика и сравнение выставляют флаги (**ZF**, **SF**, **CF**, **OF**).
3. Переходы `Jxx` их читают и переходят в зависимости от их значений к указанным меткам (или адресу).
- Самые частые «подготовители флагов»:
    - `CMP A, B` — как `A - B` (результат не сохраняется).
    - `TEST X, Y` — как `X & Y` (результат не сохраняется); удобно для «нулевое/ненулевое», проверки битов.
    - Логика/арифметика (`AND/OR/XOR/ADD/SUB/…`) — тоже выставляют флаги.

## **Типы переходов**

### *По функционалу*

| Тип                                        | Команды              | Работа со стеком     | Зависимость от флагов       |
| ------------------------------------------ | -------------------- | -------------------- | --------------------------- |
| Безусловный                                | `JMP`                | Нет                  | Нет                         |
| Процедурный - вызов программ и подпрограмм | `CALL`, `RET`        | Да (Push/Pop адреса) | Нет                         |
| Условный                                   | `JZ`, `JNE`, `JG`... | Нет                  | Да (ZF, CF, SF, OF)         |
| Цикл                                       | `LOOP`, `LOOPE`      | Нет                  | Частично (зависит от `ECX`) |

### *По дальности*

| Тип перехода | Операнд в коде              | Что меняется             | Какие команды могут           |
| ------------ | --------------------------- | ------------------------ | ----------------------------- |
| Short        | 1 байт (относительный)      | `EIP` (в пределах байта) | `JMP`, `Jxx`  `LOOP`          |
| Near         | 4 байта (относит. или абс.) | `EIP` (внутри сегмента)  | `JMP`, `CALL`, `RET`, `Jxx`   |
| Far          | 6 байт (сегмент + адрес)    | `CS` и `EIP`             | `JMP`, `CALL`, `RETF`, `IRET` |

# **Безусловный переход**

Команда `JMP <op>` ***предназначена для передачи управления по указанному адресу без проверки каких-либо условий***. В отличие от условных переходов, `JMP` срабатывает всегда.

С технической точки зрения `JMP` просто ***загружает новый адрес в регистр EIP*** (Instruction Pointer — указатель команд). Как только это происходит, процессор перестает выполнять текущую последовательность команд и начинает исполнять код по новому адресу.
### **Типы операндов**
В зависимости от того, как указан адрес, операнды делятся на прямые и косвенные:

| Тип операнда        | Чем может быть       | Описание                                                                          |
| ----------------------- | ------------------------ | ------------------------------------------------------------------------------------- |
| Прямой              | `Метка`                  | Самый простой вариант: переход на именованный участок кода в той же программе.        |
| Косвенный (Регистр) | `EAX, EBX, ECX...`       | Переход по адресу, который заранее вычислен и лежит в регистре.                       |
| Косвенный (Память)  | `[EBX]`, `[Table+ESI*4]` | Переход по адресу, записанному в ячейке памяти. Удобно для создания таблиц переходов. |

# **Условные переходы**
— команды, которые ***передают управление по новому адресу только в том случае, если выполняется определенное условие***. Большинство условных переходов ориентируются на флаги в регистре FLAGS. Если условие не выполняется, процессор просто переходит к следующей команде по порядку. 

Это основной инструмент реализации логики в программах: конструкций `if-else`, циклов `while`, `for` и проверок на ошибки.

*j+\<дальнейшее обозначение\>* 

### **Таблица обозначений для условных переходов:**

| Обозначение | Расшифровка | Значение     | Тип операндов   |
| ----------- | ----------- | ------------ | --------------- |
| e           | equal       | равно        | любой           |
| n           | not         | не           | любой           |
| g           | greater     | больше       | числа со знаком |
| l           | less        | меньше       | числа со знаком |
| a           | above       | выше(больше) | числа без знака |
| b           | below       | ниже(меньше) | числа без знака |

### **Перечень команд условного перехода**

| Тип операнда (знак/беззнак) | Мнемокод команды усл перехода | Критерий условного перехода | Значения флагов    |
| --------------------------- | ----------------------------- | --------------------------- | ------------------ |
| любые                       | je                            | O1 = O2                     | ZF=1               |
| любые                       | jne                           | O1 <> O2                    | ZF=0               |
| знак                        | jl / jnge                     | O1 < O2                     | SF <> OF           |
| знак                        | jle                           | O1 <= O2                    | SF <> OF \|\| ZF=1 |
| знак                        | jg                            | O1 > O2                     | SF = OF            |
| беззнак                     | jb                            | O1 < O2                     | CF = 1             |
| беззнак                     | jbe                           | O1 <= O2                    | CF = 1 \|\| ZF = 1 |
| беззнак                     | ja                            | O1 > O2                     | CF = 0 && ZF = 0   |
| беззнак                     | jae                           | O1 >= O2                    | CF = 0             |

## **Формирование циклов при помощи команд переходов**

### *1. Цикл с предусловием (while)*

```masm
While_Start:
    cmp eax, 10         ; Проверяем условие
    jge While_End       ; Если EAX >= 10, выходим из цикла
    
    ; --- Тело цикла ---
    inc eax             ; Увеличиваем счетчик
    
    jmp While_Start     ; Возврат к проверке
While_End:
```

### *2. Цикл с постусловием (for)*

```masm
Do_Start:
    ; --- Тело цикла ---
    dec ebx             ; Уменьшаем EBX
    
    test ebx, ebx       ; Проверяем, стал ли EBX нулем
    jnz Do_Start        ; Если не ноль (ZF=0), идем на новый круг
```

### *3. Цикл со счетчиком (for)*

```masm
mov ecx, 100        ; Загружаем счетчик
For_Start:
    ; --- Тело цикла ---
    
    dec ecx             ; Уменьшаем ECX на 1 
    jnz For_Start       ; Если ECX не равен 0, прыгаем на начало
```

# **Специфические команды формирования циклов**

### `LOOP` 
— специализированная аппаратная инструкция ***для организации циклов со счетчиком***. Она ***объединяет в себе декремент регистра-счетчика и условный переход***, что делает код более компактным. Команда ***использует регистр ECX в качестве автоматического счетчика***.

### *Алгоритм работы:*
1. Уменьшить `ECX` на 1 (`ECX := ECX - 1`).
2. Проверить значение `ECX`.
3. Если `ECX != 0`, совершить переход на указанную метку.
4. Если `ECX == 0`, управление передается следующей за `LOOP` команде.
    
> [!important] Изменения флагов
> В отличие от команды `DEC`, инструкция `LOOP` *не изменяет флаги* (включая ZF). Это позволяет проводить внутри цикла логические операции и использовать их результаты после завершения цикла.

***Пример:***
```masm
mov ecx, 100        ; Счетчик цикла
For_Start:
    ; --- Тело цикла ---
    
    loop For_Start      ; ECX = ECX - 1; если ECX != 0, прыжок
```

### `LOOP` **с дополнительными условиями**

Помимо простого счетчика, существуют команды, которые ***учитывают состояние флага нуля (ZF)***. Это полезно, когда цикл должен прерваться либо по исчерпанию счетчика, либо при достижении определенного логического условия.

#### *1. `LOOPZ` / `LOOPE` (Loop if Zero / Equal)*
Цикл продолжается, пока:
- `ECX != 0` 
- `ZF = 1` (результат предыдущей операции равен нулю или сравнению «равно»).
#### *2. `LOOPNZ` / `LOOPNE` (Loop if Not Zero / Not Equal)*
Цикл продолжается, пока:
- `ECX != 0` 
- `ZF = 0` (результат предыдущей операции не равен нулю или сравнению «не равно»).



## 9.2. Карта условных переходов (знаковые vs беззнаковые)
После `CMP A, B`:
### Знаковая интерпретация (signed)
- `JE`/`JZ` — равно (ZF=1)
- `JNE`/`JNZ` — не равно (ZF=0)
- `JL` — A < B (SF≠OF)
- `JLE` — A ≤ B (ZF=1 or SF≠OF)
- `JG` — A > B (ZF=0 and SF=OF)
- `JGE` — A ≥ B (SF=OF)
### Беззнаковая интерпретация (unsigned)
- `JB`/`JNAE` — A < B (CF=1) ; Below
- `JBE`/`JNA` — A ≤ B (CF=1 or ZF=1)
- `JA`/`JNBE` — A > B (CF=0 and ZF=0) ; Above
- `JAE`/`JNB` — A ≥ B (CF=0) ; Above or Equal
### Нулевое/ненулевое (часто после `TEST reg,reg`)
- `JZ` — ноль
- `JNZ` — не ноль
**Как выбрать?**
Если значения — **signed** (могут быть отрицательными) — `JL/JG/JLE/JGE`.
Если значения — **unsigned** — `JB/JA/JBE/JAE`.
Равенство/неравенство (`JE/JNE`) одинаково работают и там, и там.
## 9.3. Безусловные/условные переходы
- `JMP label` — безусловный.
- `Jcc label` — условный по флагам.
- **Дальность:**
    - `short` (однобайтовое смещение) ≈ −128..+127 байт — самый частый.
    - Если не хватает — компоновщик сам делает «длинный» вариант, либо используем «склейку»:
        ```asm
        jnz continue
        jmp target
        ```
continue:
```
- `JCXZ`/`JECXZ` — прыжок, если `CX/ECX == 0` (удобно перед `LOOP`).
## 9.4. Конструкции циклов на ассемблере
### while (условие) { тело }
Шаблон:
```asm
while_head:
    ; подготовка флагов для условия
    cmp   eax, ebx          ; пример
    jge   while_end         ; если условие ЛОЖЬ → выходим
    ; тело цикла
    ; ...
    jmp   while_head
while_end:
```
Пример (сумма чётных 2..10):
```asm
mov eax, 0      ; sum
mov ebx, 2      ; x
while_cmp:
    cmp ebx, 10
    jg  while_end
    add eax, ebx
    add ebx, 2
    jmp while_cmp
while_end:
```
### do { тело } while (условие)
Шаблон:
```asm
do_head:
    ; тело
    ; ...
    ; подготовить флаги
    cmp  eax, ebx
    jle  do_head           ; пока условие ИСТИНА → повторяем
```
### for (init; cond; step) { body }
Неявно разваливаем на `init` + `while`:
```asm
; init
mov ecx, N
for_head:
    ; cond
    test ecx, ecx
    jz   for_end
    ; body
    ; ...
    ; step
    dec  ecx
    jmp  for_head
for_end:
```
## 9.5. Аппаратная команда `LOOP`
- Работает с `ECX` (или `CX` для 16-битных).
- Действие: `ECX := ECX - 1`, если `ECX != 0`, перейти на метку.
- Шаблон:
```asm
mov ecx, count
L1:
    ; тело
    loop L1
```
### `LOOPZ` / `LOOPNZ`
- Доп. условие по флагу **ZF**:
    - `LOOPZ` — повторять, пока `ECX!=0` **и** `ZF=1` (aka `LOOPE`)
    - `LOOPNZ` — повторять, пока `ECX!=0` **и** `ZF=0` (aka `LOOPNE`)
Пример: повторять не более 10 раз, только пока `BX==3`:
```asm
mov  ecx, 10
for_loop:
    cmp  bx, 3
    loopz for_loop   ; ECX--, и если ECX!=0 и ZF=1 (bx==3) → назад
; выход если исчерпали ECX или bx≠3
```
**Важно:** `LOOP` медленнее пары `dec/jnz` на современных CPU, но в учебных — ок.
## 9.6. «Сравнить с нулём» и «битовые условия»
- Быстрее, чем `cmp reg,0`:
    ```asm
    test eax, eax  ; ZF=1 если ноль
    jz   is_zero
    ```
- Проверка бита `k`:
    ```asm
    test eax, 1 shl k
    jnz  bit_k_is_one
    ```
## 9.7. Мини-паттерны
### 1) Максимум из N (unsigned), массив WORD
```asm
; ESI = &arr[0], ECX = N
movzx ebx, word ptr [esi]   ; max = arr[0]
add   esi, 2
dec   ecx
jz    done
L1:
    movzx eax, word ptr [esi]
    cmp   eax, ebx          ; unsigned
    jbe   skip
    mov   ebx, eax
skip:
    add   esi, 2
    dec   ecx
    jnz   L1
done:
; EBX = max
```
### 2) Счётчик единичных битов (16 итераций)
```asm
movzx eax, word ptr a
xor   ecx, ecx
mov   edx, 16
L:
    shr  eax, 1         ; CF = выпавший бит
    adc  ecx, 0         ; count += CF
    dec  edx
    jnz  L
; ECX = количество «1»
```
### 3) Поиск символа в строке (нулём-законченной)
```asm
lea esi, buf
cld
L:
    lodsb
    test al, al
    jz   not_found
    cmp  al, 'A'
    je   found
    cmp  al, 'B'
    je   found
    jmp  L
found:
; ...
not_found:
; ...
```
## 9.8. Советы и «мины»
- **Не путай знаковые и беззнаковые переходы.**
    `JL/JG` — только для signed. Для unsigned — `JB/JA`.
- **Дальность short-переходов.** Если «не дотягивает» (−128..+127), используй «склейку» или ломай на два прыжка.
- **Флаги после MOV не меняются.** Перед `Jxx` всегда должен быть «готовящий флаги» оператор (`CMP/TEST/...`).
- **`LOOP` vs `dec/jnz`.** Для учебных — норм, но в продакшене часто быстрее `dec ecx / jnz`.
- **`cmp reg, imm` быстрее, чем через память.** Если можешь держать значение в регистре — держи.
- **Условные по ZF** (`JE/JNE`) безопасны для signed/unsigned — используйте для равенства.
## 9.9. Дополнительно (если доступно в вашем режиме)
- **SETcc r/m8** — записывает 0/1 в байт по условию (удобно вместо ветвления):
    ```asm
    cmp  eax, ebx
    setl al           ; al = (eax < ebx) ? 1 : 0  (signed)
    ```
- **CMOVcc reg, reg/mem** — условное перемещение без ветвления (Pentium Pro+):
    ```asm
    cmp   eax, ebx
    cmovl ecx, edx    ; if (eax<ebx) ecx=edx
    ```
## 9.10. Шпаргалка «какой `Jxx` выбрать?»
- Равно/не равно: `JE`/`JNE`
- Signed: `<`=`JL`, `<=`=`JLE`, `>`=`JG`, `>=`=`JGE`
- Unsigned: `<`=`JB`, `<=`=`JBE`, `>`=`JA`, `>=`=`JAE`
- Ноль/не ноль: `JZ`/`JNZ`
- Счётчик ECX: `LOOP/LOOPZ/LOOPNZ` (или `dec/jnz`)
