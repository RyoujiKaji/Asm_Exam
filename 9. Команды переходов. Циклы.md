## 9.1. Базовая идея: «сначала выставить флаги, потом прыгать»
- Арифметика и сравнение выставляют флаги (**ZF**, **SF**, **CF**, **OF**).
- Переходы `Jxx` их читают.
- Самые частые «подготовители флагов»:
    - `CMP A, B` — как `A - B` (результат не сохраняется).
    - `TEST X, Y` — как `X & Y` (результат не сохраняется); удобно для «нулевое/ненулевое», проверки битов.
    - Логика/арифметика (`AND/OR/XOR/ADD/SUB/…`) — тоже выставляют флаги.
## 9.2. Карта условных переходов (знаковые vs беззнаковые)
После `CMP A, B`:
### Знаковая интерпретация (signed)
- `JE`/`JZ` — равно (ZF=1)
- `JNE`/`JNZ` — не равно (ZF=0)
- `JL` — A < B (SF≠OF)
- `JLE` — A ≤ B (ZF=1 or SF≠OF)
- `JG` — A > B (ZF=0 and SF=OF)
- `JGE` — A ≥ B (SF=OF)
### Беззнаковая интерпретация (unsigned)
- `JB`/`JNAE` — A < B (CF=1) ; Below
- `JBE`/`JNA` — A ≤ B (CF=1 or ZF=1)
- `JA`/`JNBE` — A > B (CF=0 and ZF=0) ; Above
- `JAE`/`JNB` — A ≥ B (CF=0) ; Above or Equal
### Нулевое/ненулевое (часто после `TEST reg,reg`)
- `JZ` — ноль
- `JNZ` — не ноль
**Как выбрать?**
Если значения — **signed** (могут быть отрицательными) — `JL/JG/JLE/JGE`.
Если значения — **unsigned** — `JB/JA/JBE/JAE`.
Равенство/неравенство (`JE/JNE`) одинаково работают и там, и там.
## 9.3. Безусловные/условные переходы
- `JMP label` — безусловный.
- `Jcc label` — условный по флагам.
- **Дальность:**
    - `short` (однобайтовое смещение) ≈ −128..+127 байт — самый частый.
    - Если не хватает — компоновщик сам делает «длинный» вариант, либо используем «склейку»:
        ```asm
        jnz continue
        jmp target
        ```
continue:
```
- `JCXZ`/`JECXZ` — прыжок, если `CX/ECX == 0` (удобно перед `LOOP`).
## 9.4. Конструкции циклов на ассемблере
### while (условие) { тело }
Шаблон:
```asm
while_head:
    ; подготовка флагов для условия
    cmp   eax, ebx          ; пример
    jge   while_end         ; если условие ЛОЖЬ → выходим
    ; тело цикла
    ; ...
    jmp   while_head
while_end:
```
Пример (сумма чётных 2..10):
```asm
mov eax, 0      ; sum
mov ebx, 2      ; x
while_cmp:
    cmp ebx, 10
    jg  while_end
    add eax, ebx
    add ebx, 2
    jmp while_cmp
while_end:
```
### do { тело } while (условие)
Шаблон:
```asm
do_head:
    ; тело
    ; ...
    ; подготовить флаги
    cmp  eax, ebx
    jle  do_head           ; пока условие ИСТИНА → повторяем
```
### for (init; cond; step) { body }
Неявно разваливаем на `init` + `while`:
```asm
; init
mov ecx, N
for_head:
    ; cond
    test ecx, ecx
    jz   for_end
    ; body
    ; ...
    ; step
    dec  ecx
    jmp  for_head
for_end:
```
## 9.5. Аппаратная команда `LOOP`
- Работает с `ECX` (или `CX` для 16-битных).
- Действие: `ECX := ECX - 1`, если `ECX != 0`, перейти на метку.
- Шаблон:
```asm
mov ecx, count
L1:
    ; тело
    loop L1
```
### `LOOPZ` / `LOOPNZ`
- Доп. условие по флагу **ZF**:
    - `LOOPZ` — повторять, пока `ECX!=0` **и** `ZF=1` (aka `LOOPE`)
    - `LOOPNZ` — повторять, пока `ECX!=0` **и** `ZF=0` (aka `LOOPNE`)
Пример: повторять не более 10 раз, только пока `BX==3`:
```asm
mov  ecx, 10
for_loop:
    cmp  bx, 3
    loopz for_loop   ; ECX--, и если ECX!=0 и ZF=1 (bx==3) → назад
; выход если исчерпали ECX или bx≠3
```
**Важно:** `LOOP` медленнее пары `dec/jnz` на современных CPU, но в учебных — ок.
## 9.6. «Сравнить с нулём» и «битовые условия»
- Быстрее, чем `cmp reg,0`:
    ```asm
    test eax, eax  ; ZF=1 если ноль
    jz   is_zero
    ```
- Проверка бита `k`:
    ```asm
    test eax, 1 shl k
    jnz  bit_k_is_one
    ```
## 9.7. Мини-паттерны
### 1) Максимум из N (unsigned), массив WORD
```asm
; ESI = &arr[0], ECX = N
movzx ebx, word ptr [esi]   ; max = arr[0]
add   esi, 2
dec   ecx
jz    done
L1:
    movzx eax, word ptr [esi]
    cmp   eax, ebx          ; unsigned
    jbe   skip
    mov   ebx, eax
skip:
    add   esi, 2
    dec   ecx
    jnz   L1
done:
; EBX = max
```
### 2) Счётчик единичных битов (16 итераций)
```asm
movzx eax, word ptr a
xor   ecx, ecx
mov   edx, 16
L:
    shr  eax, 1         ; CF = выпавший бит
    adc  ecx, 0         ; count += CF
    dec  edx
    jnz  L
; ECX = количество «1»
```
### 3) Поиск символа в строке (нулём-законченной)
```asm
lea esi, buf
cld
L:
    lodsb
    test al, al
    jz   not_found
    cmp  al, 'A'
    je   found
    cmp  al, 'B'
    je   found
    jmp  L
found:
; ...
not_found:
; ...
```
## 9.8. Советы и «мины»
- **Не путай знаковые и беззнаковые переходы.**
    `JL/JG` — только для signed. Для unsigned — `JB/JA`.
- **Дальность short-переходов.** Если «не дотягивает» (−128..+127), используй «склейку» или ломай на два прыжка.
- **Флаги после MOV не меняются.** Перед `Jxx` всегда должен быть «готовящий флаги» оператор (`CMP/TEST/...`).
- **`LOOP` vs `dec/jnz`.** Для учебных — норм, но в продакшене часто быстрее `dec ecx / jnz`.
- **`cmp reg, imm` быстрее, чем через память.** Если можешь держать значение в регистре — держи.
- **Условные по ZF** (`JE/JNE`) безопасны для signed/unsigned — используйте для равенства.
## 9.9. Дополнительно (если доступно в вашем режиме)
- **SETcc r/m8** — записывает 0/1 в байт по условию (удобно вместо ветвления):
    ```asm
    cmp  eax, ebx
    setl al           ; al = (eax < ebx) ? 1 : 0  (signed)
    ```
- **CMOVcc reg, reg/mem** — условное перемещение без ветвления (Pentium Pro+):
    ```asm
    cmp   eax, ebx
    cmovl ecx, edx    ; if (eax<ebx) ecx=edx
    ```
## 9.10. Шпаргалка «какой `Jxx` выбрать?»
- Равно/не равно: `JE`/`JNE`
- Signed: `<`=`JL`, `<=`=`JLE`, `>`=`JG`, `>=`=`JGE`
- Unsigned: `<`=`JB`, `<=`=`JBE`, `>`=`JA`, `>=`=`JAE`
- Ноль/не ноль: `JZ`/`JNZ`
- Счётчик ECX: `LOOP/LOOPZ/LOOPNZ` (или `dec/jnz`)
