# **Логические операции**
Логические операции в ассемблере x86 *работают побитово* и, в отличие от арифметических, *всегда сбрасывают CF и OF*. Это связано с тем, что логические действия не могут привести к «арифметическому выходу» за пределы разрядной сетки.

| Команда | Что делает (Логика)                     | Изменяемые флаги       | Комментарий                                                                |
| ------- | --------------------------------------- | ---------------------- | -------------------------------------------------------------------------- |
| AND     | `dst = dst & src` (Побитовое И)         | CF=0, OF=0, ZF, SF, PF | Используется для сброса (маскирования) битов.                              |
| OR      | `dst = dst \| src` (Побитовое ИЛИ)      | CF=0, OF=0, ZF, SF, PF | Используется для установки конкретных битов в 1.                           |
| XOR     | `dst = dst ^ src` (Побитовое Искл. ИЛИ) | CF=0, OF=0, ZF, SF, PF | Популярный способ обнуления регистра: `xor eax, eax`.                      |
| NOT     | `dst = ~dst` (Инверсия всех битов)      | *Не меняются*          | Переводит 0 в 1 и наоборот. Состояние флагов сохраняется.                  |
| TEST    | `op1 & op2` (Сравнение через И)         | CF=0, OF=0, ZF, SF, PF | Работает как И. Результат не записывается. Используется для проверки бита. |
### *Допустимые комбинации операндов*

Для команд **AND, OR, XOR, TEST** действуют общие правила `dst, src`:
- `reg, reg` (регистр, регистр)
- `reg, mem` (регистр, память)
- `mem, reg` (память, регистр)
- `reg, imm` (регистр, константа)
- `mem, imm` (память, константа)

Команда `NOT` имеет только один операнд (`r/m`), который может быть либо регистром, либо ячейкой памяти. Константу инвертировать нельзя (`not 5` — ошибка).

### Примеры
- Сбросить биты по маске:
    ```asm
    ; сбросить биты 0 и 3 у BL
    and bl, 11110110b
    ```
- Установить биты по маске:
    ```asm
    ; установить бит 0 у BL
    or  bl, 00000001b
    ```
- Инвертировать набор битов:
    ```asm
    xor al, 11110000b
    ```
- Быстрый ноль в регистре (короче чем `mov reg,0`):
    ```asm
    xor eax, eax     ; EAX := 0
    ```
- Проверка «равно нулю» (короче, чем `cmp reg,0`):
    ```asm
    test eax, eax    ; ZF=1 если EAX==0
    jz   is_zero
    ```
- Проверка конкретных битов:
    ```asm
    test eax, 1 shl 5   ; установлен ли бит 5?
    jnz  bit5_is_one
    ```
# **Сдвиги и вращения**
| Команда и операнды       | Что делает               | Суть (Арифметика)            | Флаги (при n=1)                     |
| ------------------------ | ------------------------ | ---------------------------- | ----------------------------------- |
| SHL / SAL `r/m, imm8/CL` | Сдвиг влево              | Умножение на $2^n$           | CF=вытолкнутый, OF=XOR 2-х ст. бит  |
| SHR `r/m, imm8/CL`       | Логич. сдвиг вправо      | Деление на $2^n$ (без знака) | CF=вытолкнутый, OF=исходный ст. бит |
| SAR `r/m, imm8/CL`       | Арифм. сдвиг вправо      | Деление на $2^n$ (со знаком) | CF=вытолкнутый, OF=0                |
| ROL `r/m, imm8/CL`       | Вращение влево           | Цикл: слева → направо        | CF=вытолкнутый, OF определяется     |
| ROR `r/m, imm8/CL`       | Вращение вправо          | Цикл: справа → налево        | CF=вытолкнутый, OF определяется     |
| RCL `r/m, imm8/CL`       | Вращение влево через CF  | Цикл: бит → CF → мл. бит     | CF=вытолкнутый, OF определяется     |
| RCR `r/m, imm8/CL`       | Вращение вправо через CF | Цикл: бит → CF → ст. бит     | CF=вытолкнутый, OF определяется     |
### Примеры кода
### 1) Проверка чётности (LSB)
```asm
test ax, 1
jz   even      ; младший бит 0 → чётное
; иначе нечётное
```
### 2) Выделить байт 2 (нумерация с 0) из `EAX`
```asm
mov edx, eax
shr edx, 16
and edx, 0FFh      ; теперь EDX = байт №2
```
### 3) Установить бит k и сбросить бит m в `EBX`
```asm
or  ebx,  1 shl k
and ebx, ~(1 shl m)
```
### 4) Быстрое «складывание битов» (паритет 32-бит)
```asm
; EAX = x
xor eax, eax>>16
xor eax, eax>>8
xor eax, eax>>4
xor eax, eax>>2
xor eax, eax>>1
and eax, 1      ; 0 = чётное число «1», 1 = нечётное
```
### 5) Деление на 2: беззнаковое vs знаковое
```asm
; без знака
shr eax, 1
; со знаком (с сохранением знака)
sar eax, 1
```