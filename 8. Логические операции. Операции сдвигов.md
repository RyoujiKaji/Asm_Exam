## 8.1. Логические операции
### Базовые команды
- `AND dst, src` — побитовое И
    Флаги: `CF=0`, `OF=0`, `ZF/SF/PF` по результату.
- `OR dst, src` — побитовое ИЛИ
    Флаги: `CF=0`, `OF=0`, `ZF/SF/PF` по результату.
- `XOR dst, src` — побитовое исключающее ИЛИ
    Флаги: `CF=0`, `OF=0`, `ZF/SF/PF` по результату.
- `NOT dst` — побитовое НЕ (унарная)
    Флаги **не определяются**.
- `TEST op1, op2` — как `AND`, но **результат не сохраняется**, только флаги
    Флаги: `CF=0`, `OF=0`, `ZF/SF/PF` по (op1 & op2).
### Примеры
- Сбросить биты по маске:
    ```asm
    ; сбросить биты 0 и 3 у BL
    and bl, 11110110b
    ```
- Установить биты по маске:
    ```asm
    ; установить бит 0 у BL
    or  bl, 00000001b
    ```
- Инвертировать набор битов:
    ```asm
    xor al, 11110000b
    ```
- Быстрый ноль в регистре (короче чем `mov reg,0`):
    ```asm
    xor eax, eax     ; EAX := 0
    ```
- Проверка «равно нулю» (короче, чем `cmp reg,0`):
    ```asm
    test eax, eax    ; ZF=1 если EAX==0
    jz   is_zero
    ```
- Проверка конкретных битов:
    ```asm
    test eax, 1 shl 5   ; установлен ли бит 5?
    jnz  bit5_is_one
    ```
## 8.2. Сдвиги и вращения
### Логические сдвиги
- `SHL dst, imm/CL` — логический сдвиг влево.
    Младшие биты заполняются нулями.
- `SHR dst, imm/CL` — логический сдвиг вправо.
    Старшие биты заполняются нулями.
**Флаги (для сдвига на 1):**
`CF` = «вытолкнутый» бит;
`OF` меняется (у `SHL` = XOR старшего двух старших бит результата; у `SHR` при сдвиге на 1 — копия старшего исходного бита). Для сдвига на n>1 `OF` «неопределён».
`ZF/SF/PF` по результату.
**Применения:**
- Умножение/деление на степень 2: `shl eax, 3` → `eax*=8`, `shr eax, 1` → `eax/=2` (без знака).
### Арифметический сдвиг вправо
- `SAR dst, imm/CL` — **знаковый** сдвиг вправо: старший бит **копируется** (сохраняет знак).
### Вращения (циклические сдвиги)
- `ROL dst, imm/CL` — rotate left (бит, «выпавший» слева, входит справа).
- `ROR dst, imm/CL` — rotate right.
- Через перенос:
    - `RCL dst, imm/CL` — через `CF` слева.
    - `RCR dst, imm/CL` — через `CF` справа.
**Флаги (для вращения на 1):**
`CF` = последний «вытолкнутый» бит; 
`OF` определён для `ROL/ROR` (зависит от изменений старшего бита).
## 8.3. Таблица операций и флагов

| Операция    | CF  | OF         | ZF/SF/PF             |
| ----------- | --- | ---------- | -------------------- |
| AND/OR/XOR  | 0   | 0          | по рез-ту            |
| NOT         | —   | —          | —                    |
| TEST        | 0   | 0          | по AND               |
| SHL/SAL (1) | ←   | изменяется | по рез-ту            |
| SHR (1)     | ←   | изменяется | по рез-ту            |
| SAR (1)     | ←   | 0          | по рез-ту            |
| ROL/ROR (1) | ←   | изменяется | обычно не используют |
| RCL/RCR (1) | ←   | сложн.     | обычно не используют |
`←` — «последний сдвинутый бит попадает в CF».
## 8.4. Примеры кода
### 1) Проверка чётности (LSB)
```asm
test ax, 1
jz   even      ; младший бит 0 → чётное
; иначе нечётное
```
### 2) Выделить байт 2 (нумерация с 0) из `EAX`
```asm
mov edx, eax
shr edx, 16
and edx, 0FFh      ; теперь EDX = байт №2
```
### 3) Установить бит k и сбросить бит m в `EBX`
```asm
or  ebx,  1 shl k
and ebx, ~(1 shl m)
```
### 4) Быстрое «складывание битов» (паритет 32-бит)
```asm
; EAX = x
xor eax, eax>>16
xor eax, eax>>8
xor eax, eax>>4
xor eax, eax>>2
xor eax, eax>>1
and eax, 1      ; 0 = чётное число «1», 1 = нечётное
```
### 5) Деление на 2: беззнаковое vs знаковое
```asm
; без знака
shr eax, 1
; со знаком (с сохранением знака)
sar eax, 1
```