
```masm
.586 
.MODEL     flat, stdcall
OPTION     CASEMAP:NONE 

Include    C:\masm32\include\kernel32.inc
Include    C:\masm32\include\masm32.inc
IncludeLib C:\masm32\lib\kernel32.lib
IncludeLib C:\masm32\lib\masm32.lib

.CONST  
    String DB " is tree", 0
    MsgExit DB 13,10,"Press Enter to Exit",0

.DATA 
    Result DB 100 DUP (0)

.DATA? 
    inbuf  DB 100 DUP (?)

.CODE 
Start:     
    mov esi, OFFSET String
    cld

    ; 1. Пропускаем первое слово
SkipFirstWord:
    lodsb
    test al, al
    jz Exit             ; Если строка кончилась — второго слова нет
    cmp al, ' '
    je SkipFirstWord    ; Пропускаем ведущие пробелы (если есть)
    
Skip_letters:                     ; Цикл по буквам первого слова
    lodsb
    test al, al
    jz Exit
    cmp al, ' '
    jne Skip_letters

    ; 2. Пропускаем пробелы МЕЖДУ 1-м и 2-м словом
SkipSpaces:
    lodsb
    test al, al
    jz Exit
    cmp al, ' '
    je SkipSpaces

    ; 3. Нашли начало ВТОРОГО слова
    ; lodsb уже считал первую букву и сдвинул ESI, поэтому начало — это ESI-1
    dec esi
    mov ebx, esi        ; EBX = адрес начала второго слова

    ; 4. Ищем конец ВТОРОГО слова
FindEnd:
    lodsb
    test al, al
    jz FoundEnd         ; Конец строки — это конец слова
    cmp al, ' '
    je FoundEnd         ; Пробел — это конец слова
    jmp FindEnd

FoundEnd:
    dec esi
    mov edx, esi        ; EDX = адрес конца второго слова

    ; 5. Копируем слово в буфер Result для вывода
    ; Длина слова = EDX - EBX
    mov ecx, edx
    sub ecx, ebx        ; ECX = длина
    
    mov edi, OFFSET Result
    mov esi, ebx        ; Источник — начало слова
    rep movsb           ; Копируем байты
    mov BYTE PTR [edi], 0 ; Ставим нуль-терминатор в конце

    ; Выводим результат
    Invoke StdOut, ADDR Result

Exit:
    Invoke StdOut, ADDR MsgExit
    Invoke StdIn,  ADDR inbuf, LengthOf inbuf
    Invoke ExitProcess, 0 
End Start
```
