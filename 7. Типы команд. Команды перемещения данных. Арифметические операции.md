## 7.1. Типы команд
- **Перемещение данных:** `MOV`, `LEA`, `XCHG`, `PUSH/POP`, `MOVZX/MOVSX`.
- **Арифметика:** `ADD/SUB`, `INC/DEC`, `NEG`, `ADC/SBB`, `CMP`, `MUL/IMUL`, `DIV/IDIV`, расширители знака `CBW/CWDE/CDQ`.
- **Логика/биты:** `AND/OR/XOR/NOT`, `TEST`, сдвиги/вращения (`SHL/SHR/SAL/SAR`, `ROL/ROR/RCL/RCR`) — подробнее в темах [[8. Логические операции. Операции сдвигов|8]] и [[8.1. Битовые операции|8.1]].
- **Переходы/циклы/вызовы:** `Jxx`, `JMP`, `CALL/RET`, `LOOP` — в теме [[9. Команды переходов. Циклы|9]].
- **Строковые/репетитив:** `LODSx`, `STOSx`, `MOVSx`, `SCASx`, `CMPSx`, с префиксами `REP/REPE/REPNE`.
## 7.2. Базовые правила операндов
- Операнд может быть **регистром** (`reg`), **литералом** (`imm`), или **памятью** (`mem` = `[...]`).
- **Нельзя** память→память в большинстве команд (например, `MOV mem, mem` — запрещено).
- Разрядность строго совпадает: `BYTE/WORD/DWORD` и т. п. В MASM можно уточнять: `BYTE PTR [esi]`, `WORD PTR a`, `DWORD PTR [ebp+8]`.
## 7.3. Команды перемещения данных
### `MOV dst, src`
Копирует `src` в `dst`. Флаги **не меняет**.
- Примеры:
    - `mov eax, ebx`
    - `mov ax, [esi]` ; слово из памяти
    - `mov [ebp-4], eax` ; dword в локальную переменную
    - `mov al, 5`
### Расширение разрядности
- `MOVZX dst, src` — **нулевое** расширение (без знака).
    - `movzx eax, byte ptr [esi]` ; 0…255 → 0…255
- `MOVSX dst, src` — **знаковое** расширение (с сохранением знака).
    - `movsx eax, word ptr a` ; −32768…32767 → те же значения в 32 битах
### `LEA reg, mem` — Load Effective Address
Вычисляет **адрес** операнда и кладёт его в регистр (память **не читается**).
- `lea esi, buf` ; адрес начала буфера
- `lea eax, [ebx+ecx*4+8]` ; «арифметика адреса» без флагов
### `XCHG op1, op2`
Обмен значений (часто быстрее, чем через временный регистр). Флаги не затрагивает.
### Стек — `PUSH/POP`
- `push reg/imm/mem` → `ESP -= 4; [ESP] = значение`
- `pop reg/mem` → `операнд = [ESP]; ESP += 4`
- Используется для сохранения регистров, передачи параметров (cdecl/stdcall), временных значений.
## 7.4. Арифметические операции
### Базовые
- `ADD dst, src` — сложение: `dst = dst + src`
- `SUB dst, src` — вычитание: `dst = dst - src`
- `INC op` / `DEC op` — +1 / −1 (**CF не меняют**)
- `NEG op` — меняет знак: `op = 0 - op` (устанавливает CF=1, если `op ≠ 0`)
- `CMP op1, op2` — как `SUB op1, op2`, но **результат не сохраняет** (только флаги), для последующего `Jxx`
### Перенос/заём
- `ADC dst, src` — сложение с переносом: `dst = dst + src + CF`
- `SBB dst, src` — вычитание с заёмом: `dst = dst - src - CF`
### Умножение/деление
- **Без знака:** `MUL r/m8|r/m16|r/m32`
    - `AL * r/m8 → AX`, `AX * r/m16 → DX:AX`, `EAX * r/m32 → EDX:EAX`
- **Со знаком:** `IMUL` — гибче (есть формы с 2 и 3 операндами):
    - `imul reg, r/m, imm` → результат в `reg`, удобно для «умножить на константу»
- **Деление:** `DIV`/`IDIV`
    - Делимое: `AX` (при делении на 8-бит), `DX:AX` (на 16-бит), `EDX:EAX` (на 32-бит)
    - Частное в `AL/AX/EAX`, остаток в `AH/DX/EDX`
    - Для знакового — предварительно расширяем знак: `CBW/CWD/CDQ`.
### Расширение знака перед делением
- `CBW` — AL → AX (sign-extend 8→16)
- `CWD` — AX → DX:AX (sign-extend 16→32)
- `CDQ` — EAX → EDX:EAX (sign-extend 32→64)
## 7.5. Флаги, важные для арифметики
- **CF** (Carry) — перенос/заём при **беззнаковой** арифметике; «вышло за сетку»
- **OF** (Overflow) — переполнение **знаковой** арифметики
- **ZF** (Zero) — результат ноль
- **SF** (Sign) — знак результата (старший бит)
- **PF** (Parity) — чётность младшего байта результата
