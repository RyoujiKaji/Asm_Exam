# **Типы команд**

| Тип команд            | Что делают (общая суть)                                                               | Основные представители                                 |
| --------------------- | ------------------------------------------------------------------------------------- | ------------------------------------------------------ |
| Передачи данных       | Копируют информацию между регистрами, памятью и стеком. Не меняют флаги.              | `MOV`, `PUSH`, `POP`, `XCHG`, `LEA`                    |
| Арифметические        | Выполняют математические операции над целыми числами. Влияют на флаги (ZF, CF и др.). | `ADD`, `SUB`, `INC`, `DEC`, `MUL`, `DIV`, `CMP`        |
| Логические            | Выполняют побитовые операции (И, ИЛИ, исключающее ИЛИ, НЕ).                           | `AND`, `OR`, `XOR`, `NOT`, `TEST`                      |
| Сдвига                | Сдвигают биты в операнде влево или вправо (логически, арифметически или циклически).  | `SHL`, `SHR`, `SAL`, `SAR`, `ROL`, `ROR`               |
| Управления (Перехода) | Изменяют порядок выполнения команд (ветвление, циклы, вызов функций).                 | `JMP`, `JE`/`JZ`, `JNE`/`JNZ`, `CALL`, `RET`, `LOOP`   |
| Строковые             | Массово обрабатывают последовательности данных (байты, слова) в памяти.               | `MOVS`, `STOS`, `LODS`, `CMPS`, `SCAS` + префикс `REP` |
| Управления флагами    | Напрямую устанавливают или сбрасывают значения конкретных флагов процессора.          | `STC` (set carry), `CLC` (clear carry), `CLD`, `STD`   |
| Системные             | Управляют состоянием процессора, прерываниями и портами ввода-вывода.                 | `INT`, `IRET`, `IN`, `OUT`, `HLT`, `NOP`               |
## **Базовые правила операндов**
- ***Операнд может быть*** *регистром* (`reg`), *литералом* (`imm`), или *памятью* (`mem` = `[...]`).
- ***Нельзя память→память в большинстве команд***
- Разрядность должна строго совпадать. В MASM можно уточнять при помощи : `BYTE PTR [esi]` - возьми байт по адресу, который хранится в ESI; `WORD PTR a`, `DWORD PTR [ebp+8]`.

# **Команды передачи данных**
### `MOV dst, src`
***Копирует `src` в `dst`***. ***Флаги не меняет*.**
- Примеры:
    - `mov eax, ebx`
    - `mov ax, [esi]` ; слово из памяти
    - `mov [ebp-4], eax` ; dword в локальную переменную
    - `mov al, 5
*Ограничения:*
- ***Нельзя загружать значение в сегментный регистр напрямую из памяти;*** 
- ***Невозможна прямая пересылка из одного сегментного регистра в другой*** из-за отсутствия нужного кода операции в системе команд.
- ***регистр CS нельзя использовать как операнд-приемник***. Поскольку пара `CS:IP` всегда указывает на следующую команду, его изменение через `mov` означало бы несанкционированный переход, что недопустимо.
#### *С расширением разрядности*
- `MOVZX dst, src` — копирование с расширением без знака. - расширяет 0
    - `movzx eax, byte ptr [esi]` 
- `MOVSX dst, src` — копирование с расширением с сохранением знака. - расширяет битом знака
    - `movsx eax, word ptr a`

### `LEA reg, mem` — Load Effective Address
***Вычисляет адрес операнда и кладёт его в регистр*** (память не читается).
- `lea esi, buf` ; адрес начала буфера
- `lea eax, [ebx+ecx*4+8]` ; «арифметика адреса» без флагов

### `XCHG op1, op2`
***Обмен значений*** (часто быстрее, чем через временный регистр). ***Флаги не затрагивает.***

### `PUSH/POP`
Используется для помещения/извлечения объектов в/из стека
Стек расположен от больших адресов к меньшим -> растет в сторону уменьшения адресов
- `push reg/imm/mem` → `ESP -= 4;` - указатель вершины сдвинут для записи нового числа `[ESP] = значение` - запись числа`
- `pop reg/mem` → `операнд = [ESP]` - число вычитано; `ESP += 4` - указатель стека сдвинут в большую сторону => освобождено место в стеке`
- Используется для сохранения регистров, передачи параметров (cdecl/stdcall), временных значений.
#### *Сохранение регистра флагов*
`pushf` - сохранить в стек
`popf` - вычитать обратно в регистр

# **Арифметические операции**
### **Сложение, вычитание, сравнение**
| Команда | Операнды   | Что делает        | Изменяемые флаги | Описание                                                                  |
| ------- | ---------- | ----------------- | ---------------- | ------------------------------------------------------------------------- |
| ADD     | `dst, src` | `dst = dst + src` | CF, ZF, SF, OF   | Основная команда сложения.                                                |
| SUB     | `dst, src` | `dst = dst - src` | CF, ZF, SF, OF   | Основная команда вычитания.                                               |
| INC     | `op`       | `op = op + 1`     | ZF, SF, OF       | Инкремент. *Не изменяет CF.*                                              |
| DEC     | `op`       | `op = op - 1`     | ZF, SF, OF       | Декремент. *Не изменяет CF*.                                              |
| NEG     | `op`       | `op = 0 - op`     | CF, ZF, SF, OF   | Инвертирует знак. *CF=1, если `op ≠ 0`*.                                  |
| CMP     | `op1, op2` | `op1 - op2`       | CF, ZF, SF, OF   | Для сравнения чисел. *Результат вычитания отбрасывается, меняются флаги.* |

> [!important] Когда выставляются флаги CF и OF
> | Флаг | Полное название                   | Условие установки (=1)                                                                                                                 | Основное назначение                            |
| ---- | --------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------- |
| CF   | Carry Flag (Флаг переноса)        | Произошел перенос из старшего бита (при сложении) или заем (при вычитании).                                                            | Используется для беззнаковых (unsigned) чисел. |
| OF   | Overflow Flag (Флаг переполнения) | Результат операции не помещается в разрядную сетку знакового числа (например, сложили 2 положительных числа и получили отрицательное). | Используется для знаковых (signed) чисел.      |

### **Умножение**

При умножении двух $n$-битных чисел результат может занять до $2n$ бит. Поэтому процессор автоматически использует пару регистров для хранения итогового значения (в случае с 1 операндом).

| Тип операнда    | Множимое (уже в...) | Множитель (в команде) | Результат (Старшая : Младшая часть) |
| ------------------- | ----------------------- | ------------------------- | --------------------------------------- |
| 8 бит (byte)    | `AL`                    | `reg8` / `mem8`           | `AX` (целиком)                          |
| 16 бит (word)   | `AX`                    | `reg16` / `mem16`         | `DX` : `AX`                             |
| 32 бита (dword) | `EAX`                   | `reg32` / `mem32`         | `EDX` : `EAX`                           |

| Команда | Для чего применяется                      | Варианты и количество операндов                                                                                                                                                                            | Как выставляются флаги                                                                        |
| ------- | ----------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------- |
| MUL     | Беззнаковое умножение.                    | *1 операнд (источник):* `MUL r/m`. Второй сомножитель всегда в `AL/AX/EAX`.                                                                                                                                | *CF=1 и OF=1, если старшая часть результата не равна нулю.* Иначе оба флага = 0.              |
| IMUL    | Знаковое умножение (учитывает бит знака). | *1 операнд:* `IMUL r/m` (аналог MUL).<br><br>  <br><br>*2 операнда:* `IMUL reg, r/m` (результат в `reg`).<br><br>  <br><br>*3 операнда:* `IMUL reg, r/m, imm` (умножение на константу, результат в `reg`). | *CF=1 и OF=1, если результат не поместился в младший регистр* (произошло переполнение знака). |

### **Деление**

Деление работает строго симметрично умножению: чтобы разделить число и получить корректное частное и остаток, делимое должно быть в два раза длиннее делителя.

| Делитель (в команде) | Делимое (Старшая : Младшая) | Результат: Частное | Результат: Остаток |
| ------------------------ | ------------------------------- | ---------------------- | ---------------------- |
| 8 бит                | `AX`                            | `AL`                   | `AH`                   |
| 16 бит               | `DX` : `AX`                     | `AX`                   | `DX`                   |
| 32 бита              | `EDX` : `EAX`                   | `EAX`                  | `EDX`                  |

| Команда | Для чего применяется | Варианты и количество операндов                                                          | Комментарий                                                                              |
| ------- | -------------------- | ---------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- |
| DIV     | Беззнаковое деление. | 1 операнд (делитель): `DIV r/m`. Делимое всегда в паре `AX`, `DX:AX` или `EDX:EAX`.      | Если делитель = 0 или результат слишком велик — произойдет исключение (вылет программы). |
| IDIV    | Знаковое деление.    | 1 операнд (делитель): `IDIV r/m`. Требует подготовки знака делимого через `CBW/CWD/CDQ`. | *Остаток всегда имеет тот же знак, что и делимое.*                                       |
#### *Расширение (перед делением)*
- `CBW` — AL → AX (sign-extend 8→16)
- `CWD` — AX → DX:AX (sign-extend 16→32)
- `CDQ` — EAX → EDX:EAX (sign-extend 32→64)
