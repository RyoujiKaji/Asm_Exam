# **Команды сканирования бит**
### *Типы операндов:*
- `dst` - регистр
- `src` - регистр или память (16/32)

| Команда и операнды | Что делает (Английская расшифровка)            | Комментарии по работе                                                                                       | Флаги                                                   | Пример                                                 |
| ------------------ | ---------------------------------------------- | ----------------------------------------------------------------------------------------------------------- | ------------------------------------------------------- | ------------------------------------------------------ |
| BSF `dst, src`     | Bit Scan Forward: побитное сканирование вперед | Просмотр битов источника от 0-го до 15/31 до первой единицы. Если единица найдена, в `dst` пишется её номер | ZF=0, если единичный бит найден; ZF=1, если единиц нет. | `BSF ECX, EBX` — поиск номера младшего единичного бита |
| BSR `dst, src`     | Bit Scan Reverse: побитное сканирование назад. | Просмотр от старшего бита (15/31) к 0-му до первой единицы. В `dst` пишется позиция самой старшей единицы   | ZF=0, если единичный бит найден; ZF=1, если единиц нет  | `BSR ECX, EBX` — поиск номера старшего единичного бита |

# **Команды проверки и модификации бит**
### *Типы операндов:*
- `dst` - регистр или память (16/32)
- `src` - константа (значение 0-31)

| Команда и операнды | Что делает (Английская расшифровка)                     | Комментарии по работе                                                         | Флаги                                                                | Пример                                                         |
| ------------------ | ------------------------------------------------------- | ----------------------------------------------------------------------------- | -------------------------------------------------------------------- | -------------------------------------------------------------- |
| BTC `src, idx`     | Bit Test and Complement : проверка бита и его инверсия. | Извлекает значение бита в CF и инвертирует его значение в операнде-источнике. | CF устанавливается исходным значением бита (до выполнения инверсии). | `BTC EBX, 8` — проверить и инвертировать 8-й бит регистра EBX. |
| BTR `src, idx`     | Bit Test and Reset: проверка бита и его сброс.          | Извлекает значение бита в CF и устанавливает этот бит в операнде в 0          | CF устанавливается исходным значением бита.                          | `BTR EBX, 8` — проверить 8-й бит EBX и сбросить его в 0        |
| BTS `src, idx`     | Bit Test and Set: проверка бита и его установка.        | Извлекает значение бита в CF и устанавливает этот бит в операнде в 1          | CF устанавливается исходным значением бита.                          | `BTS EBX, 0` — проверить 0-й бит EBX и установить его в 1      |

## 1) Бит — это позиция `k` (0..31) и маска `1 shl k`
- **Проверить, установлен ли бит `k`:**
```asm
mov   eax, value
test  eax, 1 shl k      ; AND с маской, результат не сохраняется
jnz   bit_is_one        ; ZF=0 → бит = 1
; иначе ZF=1 → бит = 0
```
- **Установить бит `k` (сделать =1):**
```asm
or    value, 1 shl k
```
- **Сбросить бит `k` (сделать =0):**
```asm
and   value, NOT (1 shl k)
; или: and value, ~(1 shl k)
```
- **Инвертировать бит `k`:**
```asm
xor   value, 1 shl k
```
## 2) Много бит сразу: маскирование подмножества
- **Оставить только биты по маске `mask`, остальные в 0:**
```asm
and   eax, mask
```
- **Установить биты по маске `mask`:**
```asm
or    eax, mask
```
- **Инвертировать биты по маске `mask`:**
```asm
xor   eax, mask
```
- **Проверить, что все биты из `mask` установлены:**
```asm
mov   edx, eax
and   edx, mask
cmp   edx, mask
je    all_bits_set
```
(Или компактно: `test eax, mask` + проверка `ZF=0`, но это означает «хотя бы один бит из mask = 1», не «все».)
- **Проверить, что ни один бит из `mask` не установлен:**
```asm
test  eax, mask
jz    none_set
```
## 3) Извлечение/вставка битовых полей
Пусть поле занимает `w` бит и начинается с позиции `lo` (младший бит поля).
- **Извлечь поле в младшие биты:**
```asm
mov   edx, eax
shr   edx, lo                   ; сдвинуть вправо, чтобы поле стало в LSB
and   edx, (1 shl w) - 1        ; обнулить всё кроме w младших битов
; edx = значение поля
```
- **Вставить поле (значение в `edx`) в `eax`:**
```asm
; подготовить маску поля
mov   ecx, (1 shl w) - 1
shl   ecx, lo                   ; маска в позиции
; очистить поле в целевом слове
and   eax, NOT ecx
; ограничить значение шириной поля и сдвинуть
and   edx, (1 shl w) - 1
shl   edx, lo
; вставить
or    eax, edx
```
## 4) Быстрая «арифметика» на битах (часто спрашивают)
- **Проверка «степень двойки?» (только один бит равен 1, x>0):**
```asm
mov   eax, x
test  eax, eax
jz    no
lea   edx, [eax-1]
and   edx, eax
jz    yes_is_power_of_two
```
- **Очистить младшую установленную 1 (x := x & (x-1)):**
```asm
mov   edx, eax
dec   edx
and   eax, edx
```
- **Выделить младшую установленную 1 (x & -x):**
```asm
; для 32-бит, -x = (~x + 1). Сохранить x, если нужно далее.
mov   edx, eax
neg   edx            ; edx = -x
and   edx, eax       ; edx = lowest_set_bit
```
- **Паритет (чётность числа «1»):** (16-битный пример — как в л/р)
```asm
; EAX = x (из movzx word ptr a)
mov   edx, eax
shr   edx, 8
xor   eax, edx
mov   edx, eax
shr   edx, 4
xor   eax, edx
mov   edx, eax
shr   edx, 2
xor   eax, edx
mov   edx, eax
shr   edx, 1
xor   eax, edx
and   eax, 1         ; 0=чёт, 1=нечёт
```
- **Подсчёт единиц (вариант «счётчик» 16 итераций):**
```asm
movzx eax, word ptr a
xor   ecx, ecx                 ; count = 0
mov   edx, 16
@@:
shr   eax, 1                   ; CF = бывший младший бит
adc   ecx, 0                   ; count += CF
dec   edx
jnz   @B
; ECX = число «1»
```
- **Подсчёт единиц (Метод Кернигана, итераций = число «1»):**
```asm
movzx eax, word ptr a
xor   ecx, ecx
test  eax, eax
jz    done
@@:
inc   ecx
lea   edx, [eax-1]
and   eax, edx                 ; снимаем младшую 1-ку
jnz   @B
done:
; ECX = число «1»
```
## 5) Команды BT/BTS/BTR/BTC (бит-тест и модификация) — опционально
Эти инструкции умеют работать по индексу бита (даже >31, учитывая смещение слова):
- `BT r/m, r/imm` — заносит указанный бит в `CF`.
- `BTS r/m, r/imm` — **S**et bit (ставит 1) и в `CF` старое значение.
- `BTR r/m, r/imm` — **R**eset bit (ставит 0) и в `CF` старое значение.
- `BTC r/m, r/imm` — **C**omplement (инверсия) и в `CF` старое значение.
Пример: проверить бит `k` в `EAX`:
```asm
bt    eax, k       ; CF = выбранный бит
jc    bit_is_one   ; CF=1?
```
Плюсы: не надо строить маску вручную. Минусы: на старых CPU может быть не быстрее масок; переносимость — ок для IA-32.
## 6) Частые ошибки и тонкости
- `TEST eax, mask` проверяет **«есть ли хотя бы один общий 1-бит»**, а не «все биты маски установлены». Для «все» — сравнивай с маской.
- Не путать `SHR` (логический вправо) с `SAR` (арифметический вправо). Для знаковых делений нужен `SAR`.
- `NOT` не даёт осмысленных флагов для ветвлений — используй `TEST`/`CMP`.
- `MOV mem, mem` нельзя — только через регистр.
- Следи за разрядностью (`BYTE/WORD/DWORD`), при необходимости указывай `PTR`.
## 7) Маленький «карманный» набор макросов
```asm
; k ∈ [0..31]
mBitSet     MACRO reg32, k     : or  reg32,  1 shl k
mBitClear   MACRO reg32, k     : and reg32, NOT (1 shl k)
mBitToggle  MACRO reg32, k     : xor reg32,  1 shl k
mBitTest    MACRO reg32, k
    test reg32, 1 shl k
ENDM
```
Использование:
```asm
mBitSet   eax, 5
mBitClear ebx, 1
mBitToggle ecx, 7
mBitTest  edx, 3
jnz       bit3_is_one
```
## 8) Выжимка
- **Маска = `1 shl k`**, триггер: `AND` (сброс), `OR` (установить), `XOR` (инверсия), `TEST` (проверка).
- Для **полей**: сдвиг к нулю + маска «(1<<w)-1»; для вставки — очистить поле, затем «значение & ((1<<w)-1)» сдвинуть и `OR`.
- Быстрые трики: `x&(x-1)` (снять младшую 1), `x & -x` (выделить младшую 1), проверка степени двойки, «свёртка XOR» для паритета, `shr/adc` или Керниган — для подсчёта единиц.
- Можно использовать `BT/BTS/BTR/BTC` для точечного доступа к биту.

